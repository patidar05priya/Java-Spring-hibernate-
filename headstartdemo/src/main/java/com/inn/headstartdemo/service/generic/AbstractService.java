package com.inn.headstartdemo.service.generic;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.json.JSONObject;
import com.inn.headstartdemo.dao.generic.IGenericDao;
import com.inn.headstartdemo.utils.AdvanceSearchResult;
import com.inn.headstartdemo.utils.QueryObject;
import com.inn.headstartdemo.exceptions.application.BusinessException;
import org.apache.cxf.jaxrs.ext.search.SearchContext;
/**
 * This class represents an abstract service which provides a higher level interface 
 * to not only process business objects, but to get access to them in the first place. 
 * A business object may be created from different databases (and different DAO's), it 
 * could be decorated with information made from an HTTP request. 
 * This may have certain business logic that converts several data objects into a single, 
 * robust, business object.
 * 
 * For now since we are providing the CRUD implementation this abstract implementation
 * delegates responsibility to DAO which further interact with persistence store to complete
 * the operation.
 * 
 * @author Auto Generated By HeadStart
 * @version 1.0
 *
 * @param <Pk> represents entity primary key type.
 * @param <Entity> represents the JPA entity type to be processed.
 */
public abstract class AbstractService<Pk, Entity> implements IGenericService<Pk, Entity>{
	/**
	 * represents the data access object which provides implementation
	 * of data persistence and retrieval from the store. 
	 */
	private IGenericDao<Pk, Entity> dao;
	/**
	 * @return returns the resepective data access object instance.
	 */
	public IGenericDao<Pk, Entity> getDao() {
		return dao;
	}
	/**
	 * Concrete service class must override this to autowire the specific data access
	 * object instance with this service.
	 * @param dao
	 */
	public void setDao(IGenericDao<Pk, Entity> dao) {
		this.dao = dao;
	}
	/**
	 * @return returns the filtered entities after performing advance search.
	 * 
	 * @param queryObject represents the query.
	 */
	public AdvanceSearchResult<Entity> advanceSearch(QueryObject queryObject) {
		logger.debug("performing advance search using queryObject{}", queryObject);
		List<Entity> results = dao.find(queryObject);
		AdvanceSearchResult<Entity> asr = new AdvanceSearchResult<Entity>();
		asr.setLowerBound(queryObject.getPaginationLowerLimit());
		asr.setUpperBound(queryObject.getPaginationUpperLimit());
		asr.setResults(results);
		asr.setTotalRecords(dao.count(queryObject));
		logger.debug("filtered results {}", asr);
		return asr;
	}
	/**
	 * performs a search based on the values in the entity. All the values provided
	 * in the entity are compared using equal operator. This doesn't support regular
	 * expression based search.
	 * 
	 * @param entity represents the entity instance.
	 * @return returns the list of entities filtered after performing search.
	 */
	public List<Entity> search(Entity entity) throws BusinessException{
		String[] exclude = {};
		return dao.findByExample(entity, exclude);
	}
	/**
	 * searches the entity based on the primary key.
	 * @param primaryKey represents the primary key of the entity.
	 * @return returns the entity found in the persistence store.
	 */
	public Entity findById(Pk primaryKey) throws BusinessException{
		return dao.findByPk(primaryKey);
	}
	/**
	 * @return returns all the entities stored in the persistence store.
	 */
	public List<Entity> findAll() throws BusinessException{
		return dao.findAll();
	}
	/**
	 * creates the provided entity.
	 * @param anEntity entity to create.
	 */
	public Entity  create(Entity anEntity) throws BusinessException{
		return dao.create(anEntity);
	}
	/**
	 * updates the provided entity.
	 * @param anEntity entity to update.
	 */
	public Entity update(Entity anEntity) throws BusinessException{
		return dao.update(anEntity);
	}
	/**
	 * removes the provided entity.
	 * @param anEntity entity to remove. 
	 * NOTE: PK must be populated within the provided entity.
	 */
	public void remove(Entity anEntity) throws BusinessException{
		dao.delete(anEntity);
	}
	/**
	 * removes the provided entity.
	 * @param primaryKey entity's primary key. 
	 * 
	 */
	public void removeById(Pk primaryKey) throws BusinessException{
		dao.deleteByPk(primaryKey);
	}
	/**
	 * represents the logger instance
	 */
	private Logger logger = LoggerFactory.getLogger(AbstractService.class);
	
	
	/**
	 * search on entity with FIQL latest
	 * @param context,maxLimit,Minlimit
	 */
	public  List<Entity> searchWithLimit(SearchContext ctx,Integer maxLimit,Integer minLimit ) throws BusinessException
	{	
	
		return dao.search(ctx, maxLimit, minLimit);
		
	}
	
	/**
	 * search on entity with FIQL latest
	 * @param context,maxLimit,Minlimit,orderby,orderType
	 */
	public  List<Entity> searchWithLimitAndOrderBy(SearchContext ctx,Integer maxLimit,Integer minLimit,String orderby,String orderType )throws BusinessException
	{	
	
		return dao.search(ctx, maxLimit, minLimit,orderby,orderType);
		
	}
	
		public List<JSONObject> findAudit(Pk pk)throws BusinessException{
			
		return dao.findAudit(pk);
	}
	}
