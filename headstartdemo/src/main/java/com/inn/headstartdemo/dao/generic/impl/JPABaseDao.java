package com.inn.headstartdemo.dao.generic.impl;


import java.util.HashMap;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.PersistenceContextType;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.inn.headstartdemo.dao.generic.AbstractBaseDao;
import com.inn.headstartdemo.dao.generic.IGenericDao;
import com.inn.headstartdemo.dao.criteria.impl.JPACriteriaBuilder;
import com.inn.headstartdemo.dao.criteria.impl.JPAQueryExecutor;
import com.inn.headstartdemo.utils.QueryObject;
import com.inn.headstartdemo.utils.QueryObject.SortOrder;

/**
 * Abstract reusable JPA partial implementation of {@link IGenericDao}
 * that provides automatic handling of {@link EntityManager} within a 
 * container
 * 
 * @author Auto Generated By HeadStart
 * @version 1.0
 */
public class JPABaseDao<Pk, Entity> extends AbstractBaseDao<Pk, Entity>{
	/**
	 * logger instance
	 */
	private Logger logger = LoggerFactory.getLogger(JPABaseDao.class);
	/**
	 * represents the JPA entity manager.
	 */
	@PersistenceContext(name = "DEFAULT", type = PersistenceContextType.TRANSACTION)
	private EntityManager entityManager;

	/**
	 * This constructor needs the real type of the generic type Entity
	 * so it can be passed to the {@link EntityManager}.
	 */
	protected JPABaseDao(Class<Entity> type) {
		super(type);
		this.setCriteriaBuilder(new JPACriteriaBuilder<Entity>());
		this.setQueryExecutor(new JPAQueryExecutor<Entity>());
	}
	/**
	 * @return returns the {@link EntityManager}
	 */
	public EntityManager getEntityManager() {
		return entityManager;
	}

	/**
	 * sets the {@link EntityManager} using autowiring.
	 * @param entityManager
	 */
	@PersistenceContext
	public void setEntityManager(EntityManager entityManager) {
		this.entityManager = entityManager;
	}
	/**
	 * Creates an entity in the persistent store. 
	 * 
	 * @param anEntity Entity to create
	 * 
	 */
	public Entity create(Entity anEntity) {
		if(anEntity == null){
			logger.warn("Cannot create a null entity.");
			throw new IllegalArgumentException("Cannot create null entity["+getType().getName()+"]");
		}
		anEntity = getEntityManager().merge(anEntity);
		return anEntity;
	}
	/**
	 * Updates an entity in the persistent store. 
	 * 
	 * @param anEntity Entity to update.
	 * 
	 */
	public Entity update(Entity anEntity) {
		if(anEntity == null){
			logger.warn("Cannot update a null entity.");
			throw new IllegalArgumentException("Cannot update null entity["+getType().getName()+"]");
		}
		return getEntityManager().merge(anEntity);
	}
	/**
	 * Delete the entity from the persistent store. 
	 * Note: Entity's primary key must be populated.
	 * 
	 * @param anEntity
	 */
	public void delete(Entity anEntity) {
		if(anEntity == null){
			logger.warn("Cannot delete a null entity.");
			throw new IllegalArgumentException("Cannot delete null entity["+getType().getName()+"]");
		}
		getEntityManager().remove(getEntityManager().contains(anEntity)? anEntity: getEntityManager().merge(anEntity));
	}
	/**
	 * Delete the entity from the persistent store identified by its primary key. 
	 * 
	 * @param entityPk Primary key object of the entity.
	 */
	public void deleteByPk(Pk entityPk) {
		if(entityPk == null){
			logger.warn("Cannot delete entity["+getType().getName()+"] since specified primary key is null");
			throw new IllegalArgumentException("Cannot delete entity["+getType().getName()+"] since specified primary key is null");
		}
		Entity anEntity = this.findByPk(entityPk);
		this.delete(anEntity);
	}
	/**
	 * Checks if an entity with similar attribute values exists.
	 * 
	 * @param anEntity represents entity which is referred for equality comparison. 
	 * @return returns true if one or more entities exists else returns false.
	 */
	public boolean contains(Entity anEntity) {
		if(anEntity == null){
			logger.warn("Illegal argument null for entity["+getType().getName()+"] contains method ");
			return false;
		}

		return this.getEntityManager().contains(getEntityManager().contains(anEntity)? anEntity: getEntityManager().merge(anEntity));
	}
	/**
	 * Find by primary key.
	 * Search for an entity of the specified class and primary key.
	 * If the entity instance is contained in the persistence context
	 * it is returned from there.
	 * 
	 * @param entityPk primary key.
	 * @return the found entity instance or null if the entity does
	 * not exist
	 *
	 */
	public Entity findByPk(Pk entityPk) {
		if(entityPk == null){
			logger.warn("Cannot find entity["+getType().getName()+"] with null primary key");
			return null;
		}

		return this.getEntityManager().find(getType(), entityPk);
	}
	/**
	 * @return returns all the entities in the persistent store.
	 */
	public List<Entity> findAll() {
		return this.find(new QueryObject());
	}
	public List<Entity> findAll(String order,SortOrder sort) {
		HashMap<String, SortOrder> orderMap=new HashMap<String, QueryObject.SortOrder>();
		orderMap.put(order,sort);
		QueryObject query=new QueryObject();
		query.setOrderByMode(orderMap);
		return this.find(query);
	}
	public List<Entity> findAllWithPagination(int lowerLimit,int upperLimit) {
               QueryObject queryObject=new QueryObject();
               queryObject.setPaginationLowerLimit(lowerLimit);
               queryObject.setPaginationUpperLimit(upperLimit);
               return this.find(queryObject);
       }
       public List<Entity> findAllWithPagination(int lowerLimit,int upperLimit,String order,SortOrder sort) {
       			HashMap<String, SortOrder> orderMap=new HashMap<String, QueryObject.SortOrder>();
				orderMap.put(order,sort);
               QueryObject queryObject=new QueryObject();
               queryObject.setPaginationLowerLimit(lowerLimit);
               queryObject.setPaginationUpperLimit(upperLimit);
               queryObject.setOrderByMode(orderMap);
               return this.find(queryObject);
       }
}
