package com.inn.headstartdemo.model;
import  com.inn.headstartdemo.dao.IUsersDao;
import  com.inn.headstartdemo.security.spring.context.ContextProvider;
import com.inn.headstartdemo.model.UserConfig;
import java.util.*;
import javax.persistence.*;
import java.io.Serializable;
import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.lang.builder.HashCodeBuilder;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.apache.commons.lang.WordUtils;
import javax.persistence.Transient;
import javax.xml.bind.annotation.XmlRootElement;
import org.codehaus.jackson.annotate.JsonBackReference;
import  org.codehaus.jackson.annotate.JsonIgnore;

import org.codehaus.jackson.annotate.JsonIgnoreProperties;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.hibernate.annotations.Cascade;
/**
 * 
 * @author Auto Generated By HeadStart
 * @version 1.0
 *
 */
@NamedQueries({@NamedQuery(name="findByUserName",query="select u from Users u where u.username=:username"),
				@NamedQuery(name="findByEmail",query="select u from Users u where u.email=:email")				  })
@XmlRootElement(name="Users") @Entity
@Table(name="users")
@Audited
  @JsonIgnoreProperties(value={"hibernateLazyInitializer","handler"})
public class Users implements Serializable {

	

	@Column(name = "activationkey", length = 15)
	private String activationkey;
	
			@OneToOne(fetch=FetchType.LAZY,cascade=CascadeType.ALL)
		@JoinColumn(name="user_address", nullable=false)
		private Address userAddress;
		
		public Address getUserAddress() {
			return userAddress;
		}
		public void setUserAddress(Address userAddress) {
			this.userAddress = userAddress;
		}
	@Basic
	@Column(nullable=false, length=50)
	private String email;

	@Basic
	private Boolean enabled;
	
	@Basic
	private Boolean registeredby;

	@OneToOne(fetch=FetchType.LAZY,mappedBy="userid")
	private UserConfig userConfig;
	
	

	public Boolean getRegisteredby() {
		return registeredby;
	}
	public void setRegisteredby(Boolean registeredby) {
		this.registeredby = registeredby;
	}

	@Basic
	@Column(length=50)
	private String firstname;

	@Basic
	@Column(length=50)
	private String lastname;


     @Column(name = "profile_image")
	 @Basic(fetch=FetchType.LAZY) // this gets ignored anyway, but it is recommended for blobs
	 private byte[]  imageFile;
	 
	 public void setImageFile(byte[] imageFile) {
	  this.imageFile = imageFile;
	 }
	 @JsonIgnore
	 public byte[] getImageFile() {
	  return imageFile;
	 }
	
	@Basic
	@Column(nullable=false, length=50)
	private String password;

	@ManyToMany(targetEntity=com.inn.headstartdemo.model.Roles.class)
	@JoinTable(name="userrole", joinColumns=@JoinColumn(name="userid"), inverseJoinColumns=@JoinColumn(name="roleid"))
		@NotAudited
		private Set<Roles> roles = new HashSet<Roles>();


	@Basic
	@Column(length=20)
	private String telephone;

	@Id
	    @GeneratedValue(strategy = GenerationType.AUTO)
	 	private Integer userid;

	@Basic
	@Column(name = "modifiedTime")
	protected Date modifiedTime;
		
	public Date getModifiedTime() {
	    return modifiedTime;
	}
	public void setModifiedTime(Date modifiedTime) {
	    this.modifiedTime = modifiedTime;
	}
	public Date getCreatedTime() {
	    return createdTime;
	}
	public void setCreatedTime(Date createdTime) {
	    this.createdTime = createdTime;
	}
	@Basic
	@Column(name = "createdTime")
	protected Date createdTime;
	
	@Basic
	@Column(nullable=false, length=50)
	private String username;

	public Users() {
	}

	public Users(Integer userid) {
		this.userid = userid;
	}






	
		public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public Boolean isEnabled() {
		return enabled;
	}

	public void setEnabled(Boolean enabled) {
		this.enabled = enabled;
	}

	public String getFirstname() {
		return firstname;
	}

	public void setFirstname(String firstname) {
		this.firstname = WordUtils.capitalize(firstname);
	}

	public String getLastname() {
		return lastname;
	}

	public void setLastname(String lastname) {
		this.lastname = WordUtils.capitalize(lastname);
	}

	@JsonIgnore
	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}
	@JsonIgnore
	public Set<Roles> getRoles() {
		return roles;
	}

	public void setRoles(Set<Roles> roles) {
		this.roles = roles;
	}

	public String getTelephone() {
		return telephone;
	}

	public void setTelephone(String telephone) {
		this.telephone = telephone;
	}

	public Integer getUserid() {
		return userid;
	}

	public void setUserid(Integer userid) {
		this.userid = userid;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}


	public boolean equals(Object obj) {
		boolean returnValue = false;
		if (obj instanceof Users) {
			Users users = (Users) obj;
			EqualsBuilder equalsBuilder = new EqualsBuilder();
			equalsBuilder.appendSuper(super.equals(obj));
						equalsBuilder.append(email, users.getEmail());
			equalsBuilder.append(firstname, users.getFirstname());
			equalsBuilder.append(lastname, users.getLastname());
			equalsBuilder.append(password, users.getPassword());
			equalsBuilder.append(roles, users.getRoles());
			equalsBuilder.append(telephone, users.getTelephone());
			equalsBuilder.append(userid, users.getUserid());
			equalsBuilder.append(username, users.getUsername());
			returnValue = equalsBuilder.isEquals();
		}
		return returnValue;
	}

	public String toString() {
		return ToStringBuilder.reflectionToString(this);
	}

	public int hashCode() {
		HashCodeBuilder hashCodeBuilder = new HashCodeBuilder(17, 37);
				hashCodeBuilder.append(email);
		hashCodeBuilder.append(firstname);
		hashCodeBuilder.append(lastname);
		hashCodeBuilder.append(password);
		hashCodeBuilder.append(telephone);
		hashCodeBuilder.append(userid);
		hashCodeBuilder.append(username);
		return hashCodeBuilder.toHashCode();
	}

	@Transient
	private Boolean locked;	
	
public boolean getLockStatus(){
              
              if(locked==null){
				  IUsersDao  dao =ContextProvider.getContext().getBean(IUsersDao.class);
				  Boolean lock;
				  try {
						 lock = dao.findByUser(username);
						 locked=lock;
						 return locked;
				  } catch (Exception e) {
				
						 locked = false;
				  }
              }
              return locked;
       }
@JsonIgnore
public String getIdentifier()
{
	return "getUsername";
}
/**
 * @return the activationkey
 */
@JsonIgnore
public String getActivationkey() {
	return activationkey;
}

/**
 * @param activationkey the activationkey to set
 */

public void setActivationkey(String activationkey) {
	this.activationkey = activationkey;
}
	@JsonIgnore
	public String getPrimaryKeyIdentifier()
	{
		return ""+getUsername();

	}
	
	public UserConfig getUserConfig() {
	    return userConfig;
	}
	public void setUserConfig(UserConfig userConfig) {
	    this.userConfig = userConfig;
	}
}
